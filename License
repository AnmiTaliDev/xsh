#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <pwd.h>
#include <time.h>
#include <errno.h>
#include <signal.h>
#include <termios.h>
#include <readline/readline.h>
#include <readline/history.h>
#include <sys/types.h>
#include <fcntl.h>

#define MAX_COMMAND_LENGTH 4096
#define MAX_ARGS 512
#define MAX_PATH_LENGTH 4096
#define MAX_ALIASES 100
#define HISTORY_FILE ".xsh_history"

// ANSI цветовые коды
#define COLOR_RESET   "\001\033[0m\002"
#define COLOR_CYAN    "\001\033[36m\002"
#define COLOR_BLUE    "\001\033[34m\002"
#define COLOR_GREEN   "\001\033[32m\002"
#define COLOR_RED     "\001\033[31m\002"
#define COLOR_YELLOW  "\001\033[33m\002"
#define COLOR_MAGENTA "\001\033[35m\002"

// Цвета для синтаксиса
#define SYN_COMMAND  "\033[32m"
#define SYN_ARG      "\033[36m"
#define SYN_PIPE     "\033[31m"
#define SYN_REDIR    "\033[33m"
#define SYN_QUOTE    "\033[35m"

// Структуры
typedef struct {
    char *name;
    char *value;
} Alias;

typedef struct {
    char *name;
    char *value;
} Environment;

typedef struct {
    pid_t pid;
    char *command;
    int status;
} Job;

typedef struct {
    char history_file[MAX_PATH_LENGTH];
    int history_size;
    Alias aliases[MAX_ALIASES];
    int alias_count;
    Job jobs[MAX_ARGS];
    int job_count;
} Config;

// Глобальные переменные
Config config;
char current_dir[MAX_PATH_LENGTH];
volatile sig_atomic_t running = 1;

// Прототипы встроенных команд
int cmd_cd(char **args);
int cmd_exit(char **args);
int cmd_pwd(char **args);
int cmd_set(char **args);
int cmd_unset(char **args);
int cmd_export(char **args);
int cmd_alias(char **args);
int cmd_unalias(char **args);
int cmd_echo(char **args);
int cmd_read(char **args);
int cmd_jobs(char **args);
int cmd_fg(char **args);
int cmd_bg(char **args);
int cmd_kill(char **args);
int cmd_source(char **args);

// Структура для встроенных команд
typedef struct {
    char *name;
    int (*func)(char **);
} BuiltinCommand;

// Таблица встроенных команд
BuiltinCommand builtin_commands[] = {
    {"cd", cmd_cd},
    {"exit", cmd_exit},
    {"pwd", cmd_pwd},
    {"set", cmd_set},
    {"unset", cmd_unset},
    {"export", cmd_export},
    {"alias", cmd_alias},
    {"unalias", cmd_unalias},
    {"echo", cmd_echo},
    {"read", cmd_read},
    {"jobs", cmd_jobs},
    {"fg", cmd_fg},
    {"bg", cmd_bg},
    {"kill", cmd_kill},
    {"source", cmd_source},
    {NULL, NULL}
};

// Подсветка синтаксиса для readline
char *syntax_highlight(const char *cmd) {
    static char highlighted[MAX_COMMAND_LENGTH * 2];
    char *result = highlighted;
    int in_quote = 0;
    int is_command = 1;

    while (*cmd) {
        if (*cmd == '"' || *cmd == '\'') {
            strcpy(result, in_quote ? COLOR_RESET : SYN_QUOTE);
            result += strlen(result);
            in_quote = !in_quote;
        } else if (*cmd == '|') {
            strcpy(result, SYN_PIPE);
            result += strlen(result);
            *result++ = *cmd;
            strcpy(result, COLOR_RESET);
            result += strlen(result);
            is_command = 1;
            cmd++;
            continue;
        } else if (*cmd == '>' || *cmd == '<') {
            strcpy(result, SYN_REDIR);
            result += strlen(result);
            *result++ = *cmd;
            strcpy(result, COLOR_RESET);
            result += strlen(result);
            cmd++;
            continue;
        } else if (is_command && !isspace(*cmd)) {
            strcpy(result, SYN_COMMAND);
            result += strlen(result);
            is_command = 0;
        } else if (isspace(*cmd)) {
            strcpy(result, COLOR_RESET);
            result += strlen(result);
            *result++ = *cmd;
            if (!in_quote) is_command = 1;
            cmd++;
            continue;
        }
        *result++ = *cmd++;
    }
    strcpy(result, COLOR_RESET);
    return highlighted;
}

// Получение короткого пути
char *get_short_path(const char *path) {
    static char short_path[MAX_PATH_LENGTH];
    const char *home = getenv("HOME");
    
    if (home && strncmp(path, home, strlen(home)) == 0) {
        snprintf(short_path, sizeof(short_path), "~%s", path + strlen(home));
    } else {
        strncpy(short_path, path, sizeof(short_path) - 1);
        short_path[sizeof(short_path) - 1] = '\0';
    }
    
    return short_path;
}

// Генерация промпта
char *generate_prompt(void) {
    static char prompt[MAX_PATH_LENGTH];
    struct passwd *pw = getpwuid(getuid());
    char *short_path = get_short_path(current_dir);

    snprintf(prompt, sizeof(prompt), 
             "%s%s%s %s%s%s %s➜%s ", 
             COLOR_CYAN, pw->pw_name, COLOR_RESET,
             COLOR_BLUE, short_path, COLOR_RESET,
             COLOR_GREEN, COLOR_RESET);

    return prompt;
}

// Реализация встроенных команд
int cmd_cd(char **args) {
    if (!args[1]) {
        return chdir(getenv("HOME"));
    }
    if (chdir(args[1]) != 0) {
        perror("xsh: cd");
        return 1;
    }
    getcwd(current_dir, sizeof(current_dir));
    return 0;
}

int cmd_pwd(char **args) {
    char cwd[MAX_PATH_LENGTH];
    if (getcwd(cwd, sizeof(cwd))) {
        printf("%s\n", cwd);
        return 0;
    }
    return 1;
}

int cmd_echo(char **args) {
    int i = 1;
    while (args[i]) {
        printf("%s", args[i]);
        if (args[i + 1]) printf(" ");
        i++;
    }
    printf("\n");
    return 0;
}

int cmd_exit(char **args) {
    running = 0;
    return 0;
}

// ... (остальные команды реализуются аналогично)

// Основная функция выполнения команды
void execute_command(char *command) {
    int argc;
    char **args = parse_command(command, &argc);
    
    if (argc == 0) {
        free(args);
        return;
    }

    // Проверка на встроенные команды
    for (int i = 0; builtin_commands[i].name; i++) {
        if (strcmp(args[0], builtin_commands[i].name) == 0) {
            builtin_commands[i].func(args);
            goto cleanup;
        }
    }

    // Выполнение внешней команды
    pid_t pid = fork();
    if (pid == 0) {
        // Дочерний процесс
        execvp(args[0], args);
        fprintf(stderr, "xsh: %s: command not found\n", args[0]);
        exit(EXIT_FAILURE);
    } else if (pid < 0) {
        perror("xsh");
    } else {
        // Родительский процесс
        int status;
        waitpid(pid, &status, 0);
    }

cleanup:
    for (int i = 0; i < argc; i++) {
        free(args[i]);
    }
    free(args);
}

// Инициализация оболочки
void initialize_shell(void) {
    signal(SIGINT, handle_signal);
    signal(SIGTERM, handle_signal);

    // Загрузка конфигурации
    load_config();

    // Инициализация readline
    rl_initialize();
    
    // Загрузка истории
    char history_path[MAX_PATH_LENGTH];
    snprintf(history_path, sizeof(history_path), "%s/%s", getenv("HOME"), HISTORY_FILE);
    read_history(history_path);

    // Получение текущей директории
    getcwd(current_dir, sizeof(current_dir));
}

// Очистка при завершении
void cleanup_shell(void) {
    save_history();
    rl_cleanup_after_signal();
}

// Загрузка конфигурации
void load_config(void) {
    char config_path[MAX_PATH_LENGTH];
    snprintf(config_path, sizeof(config_path), "%s/.xshrc", getenv("HOME"));
    
    config.history_size = 1000;
    config.history_file[0] = '\0';
    if (access(config_path, F_OK) != -1) {
        FILE *file = fopen(config_path, "r");
        char line[MAX_COMMAND_LENGTH];
        while (fgets(line, sizeof(line), file)) {
            if (strncmp(line, "HISTSIZE=", 9) == 0) {
                config.history_size = atoi(line + 9);
            } else if (strncmp(line, "HISTFILE=", 9) == 0) {
                strncpy(config.history_file, line + 9, sizeof(config.history_file) - 1);
                config.history_file[strcspn(config.history_file, "\n")] = '\0';
            }
        }
        fclose(file);
    }
    if (config.history_file[0] == '\0') {
        snprintf(config.history_file, sizeof(config.history_file), "%s/%s", getenv("HOME"), HISTORY_FILE);
    }
}

// Сохранение истории
void save_history(void) {
    char history_path[MAX_PATH_LENGTH];
    snprintf(history_path, sizeof(history_path), "%s/%s", getenv("HOME"), HISTORY_FILE);
    write_history(history_path);
}

// Главная функция
int main(int argc, char *argv[]) {
    initialize_shell();
    
    char *command;
    while (running && (command = readline(generate_prompt()))) {
        // Подсветка синтаксиса при вводе
        printf("%s", syntax_highlight(command));
        
        if (strlen(command) > 0) {
            add_history(command);
            execute_command(command);
        }
        free(command);
    }
    
    cleanup_shell();
    printf("\nGoodbye!\n");
    return 0;
}